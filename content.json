{"meta":{"title":"hexBlog","subtitle":"","description":"","author":"RemyHe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-04-25T12:19:44.000Z","updated":"2021-05-18T00:38:07.978Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-04-25T11:33:35.000Z","updated":"2021-05-18T00:38:07.978Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-04-25T11:32:58.000Z","updated":"2021-05-18T00:38:07.982Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"react基础","slug":"start-react","date":"2021-05-17T22:15:55.000Z","updated":"2021-05-18T00:38:07.978Z","comments":true,"path":"2021/05/17/start-react/","link":"","permalink":"http://example.com/2021/05/17/start-react/","excerpt":"","text":"什么是 React? React 是一个用于构建用户界面的 JavaScript 库 核心专注于视图,目的实现组件化开发 组件化概念我们可以很直观的将一个复杂的页面分割成若干个独立组件,每个组件包含自己的逻辑和样式 再将这些独立组件组合完成一个复杂的页面。 这样既减少了逻辑复杂度，又实现了代码的重用 可组合：一个组件可以和其他的组件一起使用或者可以直接嵌套在另一个组件内部 可重用：每个组件都是具有独立功能的，它可以被使用在多个场景中 可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护 搭建 React 开发环境123cnpm i create-react-app -gcreate-react-app reactappnpm start JSX什么是 JSX是一种 JS 和 HTML 混合的语法,将组件的结构、数据甚至样式都聚合在一起定义组件 1234ReactDOM.render( &lt;h1&gt;Hello&lt;/h1&gt;, document.getElementById(&#x27;root&#x27;)); 什么是元素 JSX 其实只是一种语法糖,最终会通过 babeljs 转译成 createElement 语法 React 元素是构成 React 应用的最小单位 React 元素用来描述你在屏幕上看到的内容 React 元素事实上是普通的 JS 对象,ReactDOM 来确保浏览器中的 DOM 数据和 React 元素保持一致 1&lt;h1 className=&quot;title&quot; style=&#123;&#123;color:&#x27;red&#x27;&#125;&#125;&gt;hello&lt;/h1&gt; 123456React.createElement(&quot;h1&quot;, &#123; className: &quot;title&quot;, style: &#123; color: &#x27;red&#x27; &#125;&#125;, &quot;hello&quot;); createElement 的结果: 12345678910111213&#123; type:&#x27;h1&#x27;, // 元素类型 key: null, // 区分同一个父亲，不同儿子 ref: null, // 获取真实dom元素 props:&#123; className: &quot;title&quot;, children: &quot;hello&quot;, style: &#123; color: &#x27;red&#x27; &#125; &#125;, children:&quot;hello&quot;&#125; JSX 表达式可以任意地在 JSX 当中使用 JavaScript 表达式，在 JSX 当中的表达式要包含在大括号里 12345678import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;let title = &#x27;hello&#x27;;let root = document.getElementById(&#x27;root&#x27;);ReactDOM.render( &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;, root); JSX 属性 需要注意的是 JSX 并不是 HTML,更像 JavaScript 在 JSX 中属性不能包含关键字，像 class 需要写成 className,for 需要写成 htmlFor,并且属性名需要采用驼峰命名法 123456import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;ReactDOM.render( &lt;h1 className=&quot;title&quot; style=&#123;&#123; color: &#x27;red&#x27; &#125;&#125;&gt;Hello&lt;/h1&gt;, document.getElementById(&#x27;root&#x27;)); JSX 也是对象 可以在 if 或者 for 语句里使用 JSX 将它赋值给变量，当作参数传入，作为返回值都可以if 中使用 123456789101112131415import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;let root = document.getElementById(&#x27;root&#x27;);function greeting(name) &#123; if (name) &#123; return &lt;h1&gt;Hello, &#123;name&#125;!&lt;/h1&gt;; &#125; return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;&#125;const element = greeting(&#x27;zhufeng&#x27;);ReactDOM.render( element, root); for 中使用 1234567891011121314import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;let root = document.getElementById(&#x27;root&#x27;);let names = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;];let elements = [];for (let i = 0; i &lt; names.length; i++) &#123; elements.push(&lt;li&gt;&#123;names[i]&#125;&lt;/li&gt;);&#125;ReactDOM.render( &lt;ul&gt; &#123;elements&#125; &lt;/ul&gt;, root); 更新元素渲染React 元素都是 immutable 不可变的。当元素被创建之后，你是无法改变其内容或属性的。一个元素就好像是动画里的一帧，它代表应用界面在某一时间点的样子更新界面的唯一办法是创建一个新的元素，然后将它传入 ReactDOM.render()方法 123456789101112import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;let root = document.getElementById(&#x27;root&#x27;);function tick() &#123; const element = ( &lt;div&gt; &#123;new Date().toLocaleTimeString()&#125; &lt;/div&gt; ); ReactDOM.render(element, root);&#125;setInterval(tick, 1000); React 只会更新必要的部分 React DOM 首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分。 即便我们每秒都创建了一个描述整个 UI 树的新元素，React DOM 也只会更新渲染文本节点中发生变化的内容 组件 &amp; Props 可以将 UI 切分成一些独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件 组件从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素 函数(定义的)组件函数组件接收一个单一的 props 对象并返回了一个 React 元素 123456789import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;let root = document.getElementById(&#x27;root&#x27;);function Welcome(props)&#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;ReactDOM.render(&lt;Welcome name=&quot;we&quot;/&gt;, root); 类(定义的)组件1234567891011import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;let root = document.getElementById(&#x27;root&#x27;);class Welcome extends React.Component &#123; render()&#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;ReactDOM.render(&lt;Welcome name=&quot;we&quot;/&gt;, root); 组件渲染 React 元素不但可以是 DOM 标签，还可以是用户自定义的组件 当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）转换为单个对象传递给组件，这个对象被称之为 props 组件名称必须以大写字母开头 组件必须在使用的时候定义或引用它 组件的返回值只能有一个根元素 12345678910111213141516171819202122import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;let root = document.getElementById(&#x27;root&#x27;);function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;class Welcome2 extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;const element1= &lt;Welcome name=&quot;we&quot; /&gt;;console.log(element1.props.name);const element2= &lt;Welcome2 name=&quot;we2&quot; /&gt;;console.log(element1.props.name);ReactDOM.render( &lt;div&gt;&#123;element1&#125;&#123;element2&#125;&lt;/div&gt;, root); 状态 组件的数据来源有两个地方，分别是属性对象和状态对象 属性是父组件传递过来的(默认属性，属性校验) 状态是自己内部的,改变状态唯一的方式就是 setState 属性和状态的变化都会影响视图更新 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;interface Props &#123;&#125;interface State &#123; date: any&#125;class Clock extends React.Component&lt;Props, State&gt;&#123; timerID constructor(props) &#123; super(props); this.state = &#123; date: new Date() &#125;; &#125; componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 ); &#125; componentWillUnmount() &#123; clearInterval(this.timerID); &#125; tick() &#123; this.setState(&#123; date: new Date() &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&#x27;root&#x27;)); 不要直接修改 State 构造函数是唯一可以给 this.state 赋值的地方 12345678910111213141516171819202122232425262728293031323334353637383940414243import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;interface Props &#123;&#125;interface State &#123; number: number&#125;class Counter extends React.Component&lt;Props, State&gt; &#123; timerID constructor(props) &#123; super(props); this.state = &#123; number: 0 &#125;; &#125; componentDidMount() &#123; this.timerID = setInterval( () =&gt; &#123; this.setState(&#123; number: this.state.number + 1 &#125;); //this.state.number = this.state.number + 1; &#125;, 1000 ); &#125; componentWillUnmount() &#123; clearInterval(this.timerID); &#125; render() &#123; return ( &lt;div &gt; &lt;p&gt; &#123;this.state.number&#125; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt; Counter /&gt;, document.getElementById(&#x27;root&#x27;)); State 的更新可能是异步的 出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用 因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态 可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数 1234567891011121314151617181920212223242526272829303132333435import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;class Counter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; number: 0 &#125;; &#125; handleClick = () =&gt; &#123; //this.setState(&#123;number:this.state.number+1&#125;); //console.log(this.state.number); //this.setState(&#123;number:this.state.number+1&#125;); this.setState((state) =&gt; ( &#123; number: state.number + 1 &#125; )); this.setState((state) =&gt; ( &#123; number: state.number + 1 &#125; )); &#125; render() &#123; return ( &lt;div &gt; &lt;p&gt; &#123;this.state.number&#125; &lt;/p&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt; Counter /&gt;, document.getElementById(&#x27;root&#x27;)); State 的更新会被合并 当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state 123456789101112131415161718192021222324252627282930313233343536import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;class Counter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; name: &#x27;zhufeng&#x27;, number: 0 &#125;; &#125; handleClick = () =&gt; &#123; //this.setState(&#123;number:this.state.number+1&#125;); //console.log(this.state.number); //this.setState(&#123;number:this.state.number+1&#125;); this.setState((state) =&gt; ( &#123; number: state.number + 1 &#125; )); this.setState((state) =&gt; ( &#123; number: state.number + 1 &#125; )); &#125; render() &#123; return ( &lt;div &gt; &lt;p&gt;&#123;this.state.name&#125;: &#123;this.state.number&#125; &lt;/p&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt; Counter /&gt;, document.getElementById(&#x27;root&#x27;)); 事件处理 React 事件的命名采用小驼峰式（camelCase），而不是纯小写。 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串 你不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault 123456789101112131415161718192021import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;class Link extends React.Component &#123; handleClick(e) &#123; e.preventDefault(); alert(&#x27;The link was clicked.&#x27;); &#125; render() &#123; return ( &lt;a href=&quot;http://www.baidu.com&quot; onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/a&gt; ); &#125;&#125;ReactDOM.render( &lt;Link /&gt;, document.getElementById(&#x27;root&#x27;)); this12345678910111213141516class LoggingButton extends React.Component &#123; handleClick() &#123; console.log(&#x27;this is:&#x27;, this); &#125; handleClick1 = () =&gt; &#123; console.log(&#x27;this is:&#x27;, this); &#125; render() &#123; //onClick=&#123;this.handleClick.bind(this) return ( &lt;button onClick=&#123;(event) =&gt; this.handleClick(event)&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125;this 向事件处理程序传递参数 匿名函数 bind 123456789101112131415161718import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;class LoggingButton extends React.Component &#123; handleClick = (id, event) =&gt; &#123; console.log(&#x27;id:&#x27;, id); &#125;; render() &#123; return ( &lt;&gt; &lt;button onClick=&#123;(event) =&gt; this.handleClick(&#x27;1&#x27;, event)&#125;&gt; Click me &lt;/button&gt; &lt;button onClick=&#123;this.handleClick.bind(this, &#x27;1&#x27;)&#125;&gt;Click me&lt;/button&gt; &lt;/&gt; ); &#125;&#125;ReactDOM.render(&lt;LoggingButton /&gt;, document.getElementById(&#x27;root&#x27;)); Ref Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素 在 React 渲染生命周期时，表单元素上的 value 将会覆盖 DOM 节点中的值，在非受控组件中，你经常希望 React 能赋予* 组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个 defaultValue 属性，而不是 value","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"Python系列之面对对象基础","slug":"python-base-object","date":"2021-04-28T17:33:29.000Z","updated":"2021-05-18T00:38:07.978Z","comments":true,"path":"2021/04/28/python-base-object/","link":"","permalink":"http://example.com/2021/04/28/python-base-object/","excerpt":"","text":"本文尝试探讨Python面向对象的基础概念 从定义说起面向过程(Procedure-oriented)可以使用在函数中调用其他函数的方式设计我们的程序。这叫做面向过程的编程方式。它的特点是把程序分成多个步骤，用函数把这些步骤一步一步实现，使用的时候串行依次调用。 面向对象编程(Object Oriented Programming - OOP)面向对象编程是一种程序设计思想，OOP把对象作为程序的基本单元，一个对象可能包含了数据、属性和操作数据的方法。 Python支持面对对象，也支持面向过程，在Python中一切皆对象。 类(Class)与对象(Object)类(Class)是用来描述具有相同属性(Attribute)和方法(Method)对象的集合。是抽象的模版。 对象或实例(Object)是类(Class)的具体实例，即根据类创建过来一个个具体的“对象”。每个对象都拥有相同方法，但各自数据可能不尽相同。 示例比如学生都有名字和分数，他们有着共同的属性。这时我们就可以设计一个学生类, 用于记录学生的名字和分数，并自定义方法打印出他们的名字和方法。 优势 继承（inheritance）。子类可以继承父类通用类型的属性和方法。也就是在父类或者说基类里面实现一次就能被子类重用 封装(Encapsulation)。对外部隐藏有关对象工作原理的细节 多态（polymorphism）。也就是同一个方法，不同的行为，指由继承而产生的相关但不同的类，其对象对同一消息会做出不同的响应 属性(Attribute)和方法(Method)介绍 属性 对象可以使用属于它的普通变量来存储数据，这种从属于对象或类的变量就是属性，它用于描述所有对象共同特征。比如学生的名字和分数。 方法 类里面的函数，用来区别类外面的函数, 用来实现某些功能，实现对对象的操作。比如打印出学生的名字和分数。 示例要创建一个类我们需要使用关键词class. 这个学生类Student看上去应该是这样的:1234567891011121314# 创建一个学生类class Student: # 定义学生属性，初始化方法 def __init__(self, name, score): self.name = name self.score = score # 定义打印学生信息的方法 def show_score(self): print(&quot;Name: &#123;&#125;. Score: &#123;&#125;&quot;.format(self.name, self.score)) # 修改分数的方法 def update_score(self, score): self.score = score在这个案例中，我们只定义了一个抽象的类，程序并没有创建什么存储空间。只有当我们完成类的实例化(Instance)时，程序才会创建一个具体的对象（Object），并为之分配存储空间。所以这是就是上文说的对象（Object)是类（Class)的一个实例。 要创建一个具体的学生对象(Object)，我们还需要输入: 12student1 = Student(&quot;John&quot;, 100)student2 = Student(&quot;Hex&quot;, 99) 在这个案例中，Student是类，student1和student2是我们创建的具体的学生对象。当我们输入上述代码时，Python会自动调用默认的init初始构造函数来生成具体的对象。关键字self是个非常重要的参数，代表创建的对象本身。 特殊方法init，可以把我们认为必须绑定的属性传进来，将属性绑定到self，即创建的实例的身上，表示该实例拥有的特征。 123456789&gt;&gt;&gt; student1.nameJohn&gt;&gt;&gt; student2.score99&gt;&gt; student1.show_score()Name: John. Score: 100&gt;&gt; student2.update_score(88)&gt;&gt; student2.show_score()Name: Hex. Score: 88 当你创建具体的对象后，你可以直接通过student1.name和student1.score来分别获取学生的名字和分数，也可以通过student1.show_score()来直接打印学生的名字和分数。当然我们重新通过方法更新了分数，也可先看到分数确实被我们修改了。这些方法我们看到和普通函数是一样的，定义的时候传入self，调用的时候，直接在实例上面调用，不用传递self，其他参数正常传入。 我们从外部看，只有一个Student类，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，不用知道内部实现的细节。这样封装另一个好处就是，对上层调用保留接口即调用方法，具体的内部实现细节，在对象里面定义，软件架构的分层，隔离的概念就是类似思想。 类变量(class variables)与实例变量（instance variables）介绍假设我们需要在Student类里增加一个计数器number，每当一个新的学生对象(Object)被创建时，这个计数器就自动加1。由于这个计数器不属于某个具体学生，而属于Student类的，所以被称为类变量(class variables)。而姓名和分数属于每个学生对象的，所以属于实例变量(instance variables)，也被称为对象变量(object variables)。 示例这个新Student类看上去应该是这样的:123456789101112131415161718192021222324252627# 创建一个学生类class Student: # number属于类变量，不属于某个具体的学生实例 number = 0 # 定义学生属性，初始化方法 # name和score属于实例变量 def __init__(self, name, score): self.name = name self.score = score Student.number = Student.number + 1 # 定义打印学生信息的方法 def show_score(self): print(&quot;Name: &#123;&#125;. Score: &#123;&#125;&quot;.format(self.name, self.score)) # 修改分数的方法 def update_score(self, score): self.score = score# 实例化，创建对象student1 = Student(&quot;John&quot;, 100)student2 = Student(&quot;Lucy&quot;, 99)print(Student.number) # 打印2print(student1.__class__.number) # 打印2类变量和实例变量的区别很大，访问方式也不一样。 区别 类变量 类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。访问或调用类变量的正确方式是类名.变量名或者self.class.变量名。self.class自动返回每个对象的类名。 实例变量定义在方法中的变量，属于某个具体的对象。访问或调用实例变量的正确方式是对象名.变量名或者self.变量名。 实例变量即实例属性，为各个实例所有，互不干扰的；类变量即类属性，为类所有，所有实例可共享一个属性；若类变量与实例变量同名，尝试访问时，会先从实例变量里面找，没有再从类变量里面找（实例属性优先级比类属性高），所以结果可能有错误，这是要避免的 静态方法(static method)和类方法(Class method)介绍正如同有些变量只属于类，有些方法也只属于类，不属于具体的对象。你有没有注意到属于对象的方法里面都有一个self参数, 比如init(self), show_score(self) self是指对象本身。属于类的方法不使用self参数， 而使用参数cls，代表类本身。另外对类方法我们会加上@classmethod的修饰符做说明。另外一种是静态方法，它既没有self，也没有cls，用@staticmethod的修饰符做表示，方法里面的逻辑与该对象完全无关。 示例同样拿Student为例子，我们不用print函数打印出已创建学生对象的数量，而是自定义一个类方法来打印，同时也定义了静态方法，say_hello， 来打个招呼我们可以这么做: 1234567891011121314151617181920212223242526272829303132333435class Student: # number属于类变量，不属于某个具体的学生实例 number = 0 # 定义学生属性，初始化方法 # name和score属于实例变量 def __init__(self, name, score): self.name = name self.score = score Student.number = Student.number + 1 # 定义打印学生信息的方法 def show_score(self): print(&quot;Name: &#123;&#125;. Score: &#123;&#125;&quot;.format(self.name, self.score)) # 修改分数的方法 def update_score(self, score): self.score = score # 定义类方法，打印学生的数量 @classmethod def total(cls): print(&quot;Total: &#123;0&#125;&quot;.format(cls.number)) @staticmethod def say_hello(): print(&#x27;Hello!&#x27;)# 实例化，创建对象student1 = Student(&quot;John&quot;, 100)student2 = Student(&quot;Lucy&quot;, 99)Student.show_score(student1)# Name: John. Score: 100Student.total() # 打印 Total: 2 注意一下当我们使用类调用实例方法的方法时候，只有绑定实例才可以正常访问，正确调用。 类的私有属性(private attribute)和私有方法(private method)介绍我们知道了，在类的内部，有属性和方法，外部的代码可以直接的调用实例变量来操作数据，这样隐藏内部的复杂逻辑。但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：123456&gt;&gt; student1 = Student(&#x27;hex&#x27;, 60)&gt;&gt; student1.score60&gt;&gt; student1.score = 99student1.score99我们看到内部属性被外部访问，直接修改了。这是有些过度自由了，我只想该类通过自己的方法修改属性，也就是说设置为私有怎么办呢？ 在Python里面，类里面的私有属性和私有方法以双下划线__开头。私有属性或方法不能在类的外部被使用或直接访问。只有在内部可以访问。 示例我们同样看看学生类这个例子，把分数score变为私有属性，看看会发生什么。12345678910111213141516171819202122# 创建一个学生类class Student: # 定义学生属性，初始化方法 # name和score属于实例变量, 其中__score属于私有变量 def __init__(self, name, score): self.name = name self.__score = score # 定义打印学生信息的方法 def show_score(self): print(&quot;Name: &#123;&#125;. Score: &#123;&#125;&quot;.format(self.name, self.__score)) # 修改分数的方法 def update_score(self, score): self.__score = score# 实例化，创建对象student1 = Student(&quot;John&quot;, 100)student1.show_score() # 打印 Name: John, Score: 100student1.__score # 打印出错，该属性不能从外部访问。如果你将score变成score, 你将不能直接通过student1.score获取该学生的分数。show_score()可以正常显示分数，是因为它是类里面的函数，可以访问私有变量。通过update_score()可以修改我们分数，student1.score = 99也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：12345678class Student(object): ... def update_score(self, score): if 0 &lt;= score &lt;= 100: self.__score = score else: raise ValueError(&#x27;bad score&#x27;)这样通过访问限制保护，我们让代码更健壮了。 双下划线的实例变量也不是真的不能从外部访问，因为解释器对把score变量改成_Student_score，所以仍然可以通过_Studentname来访问__score变量： 12&gt;&gt;&gt; student1._Student__score99 但是Python这么做实际上只是给你建了一个围栏，你要不要翻过去完全个人的自觉性。 私有方法是同样的道理。show_score()变成，show_score()你将不能再通过student1.show_score()打印出学生的名字和分数。值得注意的是私有方法必需含有self这个参数，且把它作为第一个参数。 @property的用法介绍在上述案例中用户不能用student1.score方式访问学生分数，然而用户也就知道了score是个私有变量。根据上文的功能我分别调用了两个方法来实现，有限制的访问属性来访问学生分数，有没有一种简单方法我们让用户通过student1.score而继续保持__score私有变量的属性呢？这时我们就可以借助Python的@property装饰器了。我们知道装饰器就是动态非函数增加功能的。 示例我们可以先定义一个方法score(), 利用@property把这个函数伪装成属性。见下面例子:12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 创建一个学生类class Student: # 定义学生属性，初始化方法 # name和score属于实例变量, 其中score属于私有变量 def __init__(self, name, score): self.name = name self.__score = score # 利用property装饰器把函数伪装成属性 @property def score(self): return self.__score @property.setter def score(self, score): if not isinstance(score, int): raise ValueError(&#x27;score must be an integer!&#x27;) if score &lt; 0 or score &gt; 100: raise ValueError(&#x27;score must between 0 ~ 100!&#x27;) self._score = score def get_score(self): return self.__score def set_score(self): if not isinstance(score, int): raise ValueError(&#x27;score must be an integer!&#x27;) if score &lt; 0 or score &gt; 100: raise ValueError(&#x27;score must between 0 ~ 100!&#x27;) self._score = score 这是第二种方法 # score = property(get_score, set_score) # 实例化，创建对象&gt;&gt;&gt; student1 = Student(&quot;John&quot;, 100)&gt;&gt;&gt; student1.score100&gt;&gt;&gt; student1.score = 60&gt;&gt;&gt; student1.score60&gt;&gt;&gt; student1.score = 999Traceback (most recent call last): ...ValueError: score must between 0 ~ 100!注意： 一旦给函数加上一个装饰器@property,调用函数的时候不用加括号就可以直接调用函数了。把一个getter方法变成属性，只需要加上@property，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作。 @property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。 类的继承(Inheritance)介绍面向对象的编程带来的最大好处之一就是代码的重用，实现这种重用的方法之一是通过继承(Inheritance)。你可以先定义一个基类(Base class)或父类(Parent class)，再按通过class 子类名（父类名)来创建子类(Child class)。这样子类就可以从父类那里获得其已有的属性与方法，这种现象叫做类的继承。 示例我们再看另一个例子，老师和学生同属学校成员，都有姓名和年龄的属性，然而老师有工资这个专有属性，学生有分数这个专有属性。这时我们就可以定义一个学校成员父类，2个子类。12345678910111213141516171819202122232425262728293031323334353637383940414243# 创建父类学校成员SchoolMemberclass SchoolMember: def __init__(self, name, age): self.name = name self.age = age def tell(self): # 打印个人信息 print(&#x27;Name:&quot;&#123;&#125;&quot; Age:&quot;&#123;&#125;&quot;&#x27;.format(self.name, self.age), end=&quot; &quot;)# 创建子类老师 Teacherclass Teacher(SchoolMember): def __init__(self, name, age, salary): SchoolMember.__init__(self, name, age) # 利用父类进行初始化 self.salary = salary # 方法重写(或覆盖) def tell(self): SchoolMember.tell(self) print(&#x27;Salary: &#123;&#125;&#x27;.format(self.salary))# 创建子类学生Studentclass Student(SchoolMember): def __init__(self, name, age, score): SchoolMember.__init__(self, name, age) self.score = score def tell(self): SchoolMember.tell(self) print(&#x27;score: &#123;&#125;&#x27;.format(self.score))teacher1 = Teacher(&quot;John&quot;, 44, &quot;$60000&quot;)student1 = Student(&quot;Mary&quot;, 12, 99)teacher1.tell() # 打印 Name:&quot;John&quot; Age:&quot;44&quot; Salary: $60000student1.tell() # Name:&quot;Mary&quot; Age:&quot;12&quot; score: 99上述代码中，你注意到以下几点了吗？ 在创建子类的过程中，你需要手动调用父类的构造函数init来完成子类的构造。 在子类中调用父类的方法时，需要加上父类的类名前缀，且需要带上self参数变量。比如SchoolMember.tell(self), 这个可以通过使用super关键词简化代码。 如果子类调用了某个方法(如tell())或属性，Python会先在子类中找，如果找到了会直接调用。如果找不到才会去父类找。这为方法重写带来了便利。 实际Python编程过程中，一个子类可以继承多个父类，原理是一样的。第一步总是要手动调用init构造函数。 super()super()关键字调用父类方法 在子类当中可以通过使用super关键字来直接调用父类的中相应的方法，简化代码。在下面例子中，学生子类调用了父类的tell()方法。super().tell()等同于SchoolMember.tell(self)。当你使用Python super()关键字调用父类方法时时，注意去掉括号里self这个参数。 1234567891011# 创建子类学生Studentclass Student(SchoolMember): def __init__(self, name, age, score): SchoolMember.__init__(self, name, age) self.score = score def tell(self): super().tell() # 等同于 SchoolMember.tell(self) # pyhotn2的需要显示的写明，super(Student, self).tell() print(&#x27;score: &#123;&#125;&#x27;.format(self.score)) 方法解析顺序(Method Resolution Order- MRO)介绍其方法（属性）可能定义在当前类，也可能来自于基类，所以在方法调用时就需要对当前类和基类进行搜索以确定方法所在的位置。其搜索顺序就是方法解析顺序。这里我们来一个测试验证一下。 12345678910111213class A: def run(self): print(&#x27;A.run&#x27;) class B(A): pass class C(A): def run(self): print(&#x27;C.run&#x27;) class D(B, C): pass 继承图示1234567 A / \\ / \\B C \\ / \\ / D 经典类的顺序Python 2中可用的形式，一种简单的MRO方法，从左到右的深度优先遍历。对于菱形继承，调用不是我们希望的结果。我们知道C.run()是A.run()更具体的版本，但实际会调用A.run()。123456789&gt;&gt;&gt; import inspect&gt;&gt;&gt; inspect.getmro(D)(&lt;class classic_mro.D at 0x1080b67a0&gt;,&lt;class classic_mro.B at 0x1080b6668&gt;,&lt;class classic_mro.A at 0x1080b6738&gt;,&lt;class classic_mro.C at 0x1080b66d0&gt;)&gt;&gt;&gt; d = D()&gt;&gt;&gt; d.run()A.run()查找结果是[D, B, A, C] 新式类顺序Python3中的新式类，都继承自ojbect,采用C3广度优先算法来做搜索MRO，多重继承更符合实际情况。如下例子:我们看到查找结果为[D, B, A, C]12345678910&gt;&gt;&gt; import inspect&gt;&gt;&gt; inspect.getmro(D)(&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)&gt;&gt;&gt; d = D()&gt;&gt;&gt; d.run()C.run() 参考 https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208","categories":[{"name":"python系列","slug":"python系列","permalink":"http://example.com/categories/python%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"Python系列之装饰器","slug":"python-decorator","date":"2021-04-28T17:31:15.000Z","updated":"2021-05-18T00:38:07.978Z","comments":true,"path":"2021/04/28/python-decorator/","link":"","permalink":"http://example.com/2021/04/28/python-decorator/","excerpt":"","text":"引言Python的装饰器(decorator)可以说是Python的一个神器，它可以在不改变一个函数代码和调用方式的情况下给函数添加新的功能。Python的装饰器同时也是Python学习从入门到精通过程中必需要熟练掌握的知识。小编我当初学习Python时差点被装饰器搞晕掉，今天尝试用浅显的语言解释下Python装饰器的工作原理及如何编写自己的装饰器吧。 本质Python装饰器的本质 Python的装饰器本质上是一个嵌套函数，它接受被装饰的函数(func)作为参数，并返回一个包装过的函数。这样我们可以在不改变被装饰函数的代码的情况下给被装饰函数或程序添加新的功能。Python的装饰器广泛应用于缓存、权限校验(如django中的@login_required和@permission_required装饰器)、性能测试(比如统计一段程序的运行时间)和插入日志等应用场景。有了装饰器，我们就可以抽离出大量与函数功能本身无关的代码，增加一个函数的重用性。 试想你写了很多程序，一直运行也没啥问题。有一天老板突然让你统计每个程序都运行了多长时间并比较下运行效率。此时如果你去手动修改每个程序的代码一定会让你抓狂，而且还破坏了那些程序的重用性。聪明的程序员是绝不能干这种蠢事的。此时你可以编写一个@time_it的装饰器(代码如下所示)。如果你想打印出某个函数或程序运行时间，只需在函数前面@一下，是不是很帅?1234567891011121314151617import timedef time_it(func): def inner(): start = time.time() func() end = time.time() print(&#x27;用时:&#123;&#125;秒&#x27;.format(end-start)) return inner@time_itdef func1(): time.sleep(2) print(&quot;Func1 is running.&quot;)if __name__ == &#x27;__main__&#x27;: func1()运行结果如下: Func1 is running. 用时:2.0056326389312744 由于Python装饰器的工作原理主要依赖于嵌套函数和闭包，所以我们必须先对嵌套函数和闭包有深入的了解。嵌套函数和闭包几乎是Python工作面试必考题哦。 嵌套函数如果在一个函数的内部还定义了另一个函数(注意: 是定义，不是引用!），这个函数就叫嵌套函数。外部的我们叫它外函数，内部的我们叫他内函数。 我们先来看一个最简单的嵌套函数的例子。我们在outer函数里又定义了一个inner函数，并调用了它。你注意到了吗? 内函数在自己作用域内查找局部变量失败后，会进一步向上一层作用域里查找。12345678def outer(): x = 1 def inner(): y = x + 1 print(y) inner()outer() #输出结果 2如果我们在外函数里不直接调用内函数，而是通过return inner返回一个内函数的引用 这时会发生什么呢? 你将会得到一个内函数对象，而不是运行结果。12345678910def outer(): x = 1 def inner(): y = x + 1 print(y) return innerouter() # 输出&lt;function outer.&lt;locals&gt;.inner at 0x039248E8&gt;f1 = outer()f1() # 输出2上述这个案例比较简单，因为outer和inner函数都是没有参数的。我们现在对上述代码做点改动，加入参数。你可以看到外函数的参数或变量可以很容易传递到内函数。1234567891011def outer(x): a = x def inner(y): b = y print(a+b) return innerf1 = outer(1) # 返回inner函数对象f1(10) # 相当于inner(10)。输出11 如果上例中外函数的变量x换成被装饰函数对象(func)，内函数的变量y换成被装饰函数的参数，我们就可以得到一个通用的装饰器啦(如下所示)。你注意到了吗? 我们在没对func本身做任何修改的情况下，添加了其它功能, 从而实现了对函数的装饰。12345def decorator(func): def inner(*args, **kwargs): add_other_actions() return func(*args, **kwargs) return inner仔细再读读上面这段代码，我们的decorator返回的仅仅是inner函数吗? 答案是不。它返回的其实是个闭包(Closure)。整个装饰器的工作都依赖于Python的闭包原理。 闭包(Closure)闭包是Python编程一个非常重要的概念。如果一个外函数中定义了一个内函数，且内函数体内引用到了体外的变量，这时外函数通过return返回内函数的引用时，会把定义时涉及到的外部引用变量和内函数打包成一个整体（闭包）返回。我们在看下之间案例。我们的outer方法返回的只是内函数对象吗? 错。我们的outer函数返回的实际上是一个由inner函数和外部引用变量(a)组成的闭包!123456789101112def outer(x): a = x def inner(y): b = y print(a+b) return innerf1 = outer(1) # 返回inner函数对象+局部变量1(闭包)f1(10) # 相当于inner(10)。输出11一般一个函数运行结束的时候，临时变量会被销毁。但是闭包是一个特别的情况。当外函数发现，自己的临时变量会在将来的内函数中用到，自己在结束的时候，返回内函数的同时，会把外函数的临时变量同内函数绑定在一起。这样即使外函数已经结束了，内函数仍然能够使用外函数的临时变量。这就是闭包的强大之处。 如何编写一个通用的装饰器 我们现在可以开始动手写个名为hint的装饰器了，其作用是在某个函数运行前给我们提示。这里外函数以hint命名，内函数以常用的wrapper(包裹函数)命名。123456789def hint(func): def wrapper(*args, **kwargs): print(&#x27;&#123;&#125; is running&#x27;.format(func.__name__)) return func(*args, **kwargs) return wrapper@hintdef hello(): print(&quot;Hello!&quot;)我们现在对hello已经进行了装饰，当我们调用hello()时，我们可以看到如下结果。123&gt;&gt;&gt; hello()hello is running.Hello!值得一提的是被装饰器装饰过的函数看上去名字没变，其实已经变了。当你运行hello()后，你会发现它的名字已经悄悄变成了wrapper，这显然不是我们想要的(如下图所示)。这一点也不奇怪，因为外函数返回的是由wrapper函数和其外部引用变量组成的闭包。12&gt;&gt;&gt; hello.__name__&#x27;wrapper&#x27;为了解决这个问题保证装饰过的函数name属性不变，我们可以使用functools模块里的wraps方法，先对func变量进行wraps。下面这段代码可以作为编写一个通用装饰器的示范代码，注意收藏哦。 12345678910111213from functools import wrapsdef hint(func): @wraps(func) def wrapper(*args, **kwargs): print(&#x27;&#123;&#125; is running&#x27;.format(func.__name__)) return func(*args, **kwargs) return wrapper@hintdef hello(): print(&quot;Hello!&quot;) 恭喜你，你已经学会写一个比较通用的装饰器啦，并保证装饰过的函数name属性不变啦。当然使用嵌套函数也有缺点，比如不直观。这时你可以借助Python的decorator模块(需事先安装)可以简化装饰器的编写和使用。如下所示。123456from decorator import decorator@decoratordef hint(func, *args, **kwargs): print(&#x27;&#123;&#125; is running&#x27;.format(func.__name__)) return func(*args, **kwargs)编写带参数的高级装饰器 前面几个装饰器一般是内外两层嵌套函数。如果我们需要编写的装饰器本身是带参数的，我们需要编写三层的嵌套函数，其中最外一层用来传递装饰器的参数。现在我们要对@hint装饰器做点改进，使其能通过@hint(coder=”John”)传递参数。该装饰器在函数运行前给出提示的时候还显示函数编写人员的名字。完整代码如下所示:1234567891011121314151617from functools import wrapsdef hint(coder): def wrapper(func): @wraps(func) def inner_wrapper(*args, **kwargs): print(&#x27;&#123;&#125; is running&#x27;.format(func.__name__)) print(&#x27;Coder: &#123;&#125;&#x27;.format(coder)) return func(*args, **kwargs) return inner_wrapper return wrapper@hint(coder=&quot;John&quot;)def hello(): print(&quot;Hello!&quot;)下面这段代码是一段经典的Python装饰器代码，显示了@cache这个装饰器怎么编写和工作的。它需要使用缓存实例做为一个参数，所以也是三层嵌套函数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import timefrom functools import wraps# 装饰器增加缓存功能def cache(instance): def wrapper(func): @wraps(func) def inner_wrapper(*args, **kwargs): # 构建key: key =&gt; func_name::args::kwargs joint_args = &#x27;,&#x27;.join((str(x) for x in args)) joint_kwargs = &#x27;,&#x27;.join(&#x27;&#123;&#125;=&#123;&#125;&#x27;.format(k, v) for k, v in sorted(kwargs.items())) key = &#x27;&#123;&#125;::&#123;&#125;::&#123;&#125;&#x27;.format(func.__name__,joint_args, joint_kwargs) # 根据key获取结果。如果key已存在直接返回结果，不用重复计算。 result = instance.get(key) if result is not None: return result # 如果结果不存在，重新计算，缓存。 result = func(*args, **kwargs) instance.set(key, result) return result return inner_wrapper return wrapper# 创建字典构造函数，用户缓存K/V键值对class DictCache: def __init__(self): self.cache = dict() def get(self, key): return self.cache.get(key) def set(self, key, value): self.cache[key] = value def __str__(self): return str(self.cache) def __repr__(self): return repr(self.cache)# 创建缓存对象cache_instance = DictCache()# Python语法糖调用装饰器@cache(cache_instance)def long_time_func(x): time.sleep(x) return x# 调用装饰过函数long_time_func(3)基于类实现的装饰器Python的装饰器不仅可以用嵌套函数来编写，还可以使用类来编写。其调用init方法创建实例，传递参数，并调用call方法实现对被装饰函数功能的添加。12345678910111213141516171819202122232425from functools import wraps#类的装饰器写法， 不带参数class Hint(object): def __init__(self, func): self.func = func def __call__(self, *args, **kwargs): print(&#x27;&#123;&#125; is running&#x27;.format(self.func.__name__)) return self.func(*args, **kwargs)#类的装饰器写法， 带参数class Hint(object): def __init__(self, coder=None): self.coder = coder def __call__(self, func): @wraps(func) def wrapper(*args, **kwargs): print(&#x27;&#123;&#125; is running&#x27;.format(func.__name__)) print(&#x27;Coder: &#123;&#125;&#x27;.format(self.coder)) return func(*args, **kwargs) # 正式调用主要处理函数 return wrapper 小结本文总结了什么是Python的装饰器及其工作原理，并重点介绍了嵌套函数和闭包原理。最后详细展示了如何编写一个通用装饰器及带参数的高级装饰器, 包括使用类来编写装饰器。大家要熟练掌握哦。","categories":[{"name":"python系列","slug":"python系列","permalink":"http://example.com/categories/python%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"Javascript中的this、call、apply、bind的理解与应用","slug":"js-this-call-apply","date":"2021-04-28T17:30:41.000Z","updated":"2021-05-18T00:38:07.978Z","comments":true,"path":"2021/04/28/js-this-call-apply/","link":"","permalink":"http://example.com/2021/04/28/js-this-call-apply/","excerpt":"","text":"基本概念在js函数内部有一个特殊的对象就是this,行为和Java中的this大致类似。this引用的是函数据以执行的环境对象-或者也可以说是this的值(当在网页的全局作用域中调用函数时,this对象引用的就是window).12345678window.color = &#x27;red&#x27;var o = &#123;color: &#x27;blue&#x27;&#125;function sayColor() &#123; alert(this.color)&#125;sayColor() // redo.sayColor = sayColoro.sayColor() // bule我们可以清晰的看到sayColor()是在全局作用域中定义的，它引用this对象。由于在调用函数之前，this的值不确定，因此this可能会在代码中执行过程中引用不同的对象。 函数名称仅仅只是一个指针变量,即是在不同环境中调用，仍然是同一个函数。 看一个例子增加理解，this永远指向最后调用它的那对象 1234567891011var color = &quot;red&quot; function fn() &#123; var color = &#x27;blue&#x27; innerFunction(); function innerFunction() &#123; console.log(this.color); // red &#125; &#125; fn() 改变this的指向根据前文我们知道this 的指向并不是在创建的时候就可以确定的，那么如何来改变或者绑定this的指向呢?答案有四: 在函数内部使用 _this = this 使用ES6箭头函数 new实例一个对象 使用apply，call，bind 来个例子: 12345678910111213var color = &quot;red&quot; var a = &#123; color: &quot;blue&quot;, func1: function () &#123; console.log(this.color) &#125;, func2: function () &#123; setTimeout(function () &#123; this.func1() &#125;, 100); &#125; &#125;; a.func2() // this.func1 is not a function 这个例子这种情况是会报错的,setTimeout作为匿名函数,this是永远指向window,在 window 中并没有 func1 函数。 在函数内部使用 _this = this1234567891011121314var color = &quot;red&quot; var a = &#123; color: &quot;blue&quot;, func1: function () &#123; console.log(this.color) &#125;, func2: function () &#123; var _this = this setTimeout(function () &#123; _this.func1() &#125;, 100); &#125; &#125;; a.func2() // blue 首先设置 var _this = this，这里的 this 是调用 func2 的对象 a，为了防止在 func2 中的 setTimeout 被 window 调用而导致的在 setTimeout 中的 this 为 window。我们将 this(指向变量 a) 赋值给一个变量 _this，这样，在 func2 中我们使用 _this 就是指向对象 a 了。 使用ES6箭头函数12345678910111213var color = &quot;red&quot; var a = &#123; color: &quot;blue&quot;, func1: function () &#123; console.log(this.color) &#125;, func2: function () &#123; setTimeout(() =&gt; &#123; this.func1() &#125;, 100); &#125; &#125;; a.func2() // blue 键头函数的 this 始终指向函数定义时的 this，而非执行时。，箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。 new一个对象如果函数调用前使用了 new 关键字, 则是调用了构造函数。这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象.我们换一个例子1234567891011function fruits() &#123;&#125; fruits.prototype = &#123; color: &quot;red&quot;, say: function() &#123; console.log(&quot;My color is &quot; + this.color); &#125;&#125; var apple = new fruits()apple.say() //My color is red这里将一个对象赋值给fruits的原型,实例化的对象都能共享一些属性和方法，具体原型，原型链，和继承在另外一篇文章会详细介绍,我们看到的结果是对于apple调用函数的this同样可以正确识别到color的属性。 apply、call在js中，call 和 apply 都是在特定的作用域中调用函数，等于设置了函数体内的this对象的值。如果我们有一个对象banana= {color : “yellow”} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法：12345banana = &#123; &#x27;color&#x27;: &#x27;yrllow&#x27;&#125;apple.say.call(banana) // My color is yellowapply.say.apply(banana) // My color is yellow所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本例子中banana没有say方法），但是其他的有（本例子中apple有say方法），我们可以借助call或apply用其它对象的方法来操作。 apply、call 区别对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下：123var func = function(arg1, arg2) &#123; &#125;call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里,或者是arguments对象。就可以通过如下方式来调用：123func.call(this, arg1, arg2)func.apply(this, [arg1, arg2])func.apply(this, arguments) 常见apply call应用数组之间追加1234var array1 = [12 , &quot;foo&quot; , &#123;name:&quot;Joe&quot;&#125; , -2458]; var array2 = [&quot;Doe&quot; , 555 , 100]; Array.prototype.push.apply(array1, array2); // array1 值为 [12 , &quot;foo&quot; , &#123;name:&quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100] 获取数组中的最大值和最小值123var numbers = [5, 458 , 120 , -215 ]; var maxInNumbers = Math.max.apply(Math, numbers), //458 maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458 number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。 验证是否是数组（前提是toString()方法没有被重写过）123functionisArray(obj)&#123; return Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27; ;&#125; 类（伪）数组使用数组方法1var domNodes = Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;)); Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。 apply,call面试题练习定义一个 log 方法，让它可以代理 console.log 方法，常见的解决方法是：12345function log(msg) &#123; console.log(msg);&#125;log(1); //1log(1,2); //1上面方法可以解决最基本的需求，但是当传入参数的个数是不确定的时候，上面的方法就失效了，这个时候就可以考虑使用 apply 或者 call，注意这里传入多少个参数是不确定的，所以使用apply是最好的，方法如下：12345function log()&#123; console.log.apply(console, arguments);&#125;;log(1); //1log(1,2); //1 2 接下来的要求是给每一个 log 消息添加一个”(app)”的前辍，比如：1log(&quot;hello world&quot;); //(app)hello world该怎么做比较优雅呢?这个时候需要想到arguments参数是个伪数组，通过 Array.prototype.slice.call 转化为标准数组，再使用数组方法unshift，像这样：123456function log()&#123; var args = Array.prototype.slice.call(arguments); args.unshift(&#x27;(app)&#x27;); console.log.apply(console, args);&#125;; bindbind()最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。常见的错误就像上面的例子一样，将方法从对象中拿出来，然后调用，并且希望this指向原来的对象。如果不做特殊处理，一般会丢失原来的对象。使用bind()方法能够很漂亮的解决这个问题一个简单的例子：123456789var bar = function()&#123;console.log(this.x)&#125;var foo = &#123;x:3&#125;bar(); // undefinedvar func = bar.bind(foo)func() // 3这里我们创建了一个新的函数 func，当使用 bind() 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。上面例题中用bind可以修改未如下: 12345678910111213var color = &quot;red&quot; var a = &#123; color: &quot;blue&quot;, func1: function () &#123; console.log(this.color) &#125;, func2: function () &#123; setTimeout(function () &#123; this.func1() &#125;.bind(a), 100); &#125; &#125;; a.func2() // blue 偏函数bind()的另一个最简单的用法是使一个函数拥有预设的初始参数。只要将这些参数（如果有的话）作为bind()的参数写在this后面。当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。123456789101112131415161718192021222324252627function list() &#123; return Array.prototype.slice.call(arguments)&#125;var list1 = list(1, 2, 3); // [1, 2, 3]// 预定义参数37var leadingThirtysevenList = list.bind(undefined, 37)var list2 = leadingThirtysevenList(); // [37]var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]和setTimeout一起使用function Bloomer() &#123; this.petalCount = Math.ceil(Math.random() * 12) + 1&#125;// 1秒后调用declare函数Bloomer.prototype.bloom = function() &#123; window.setTimeout(this.declare.bind(this), 100)&#125;;Bloomer.prototype.declare = function() &#123; console.log(&#x27;我有 &#x27; + this.petalCount + &#x27; 朵花瓣!&#x27;)&#125;;var bloo = new Bloomer()bloo.bloom() //我有 5 朵花瓣!注意：对于事件处理函数和setInterval方法也可以使用上面的方法 绑定函数作为构造函数绑定函数也适用于使用new操作符来构造目标函数的实例。当使用绑定函数来构造实例，注意：this会被忽略，但是传入的参数仍然可用。12345678910111213141516171819202122232425function Point(x, y) &#123; this.x = x this.y = y&#125;Point.prototype.toString = function() &#123; console.log(this.x + &#x27;,&#x27; + this.y)&#125;var p = new Point(1, 2)p.toString() // &#x27;1,2&#x27;var emptyObj = &#123;&#125;var YAxisPoint = Point.bind(emptyObj, 0/*x*/)// 实现中的例子不支持,// 原生bind支持:var YAxisPoint = Point.bind(null, 0/*x*/)var axisPoint = new YAxisPoint(5)axisPoint.toString() // &#x27;0,5&#x27;axisPoint instanceof Point // trueaxisPoint instanceof YAxisPoint // truenew Point(17, 42) instanceof YAxisPoint // true 捷径bind()也可以为需要特定this值的函数创造捷径。 例如要将一个类数组对象转换为真正的数组，可能的例子如下：12345var slice = Array.prototype.slice// ...slice.call(arguments)如果使用bind()的话，情况变得更简单：123456var unboundSlice = Array.prototype.slice;var slice = Function.prototype.call.bind(unboundSlice)// ...slice(arguments) apply、call、bind比较那么 apply、call、bind 三者相比较，之间又有什么异同呢？何时使用 apply、call，何时使用 bind 呢。简单的一个例子：12345678910111213var obj = &#123; x: 81&#125; var foo = &#123; getX: function() &#123; return this.x &#125;&#125; console.log(foo.getX.bind(obj)()) //81console.log(foo.getX.call(obj)) //81console.log(foo.getX.apply(obj)) //81三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。 也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。 总结 this表示函数据以执行的环境对象,this指向的是最后调用它的对象 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的第一个参数都是this要指向的对象； apply 、 call 、bind 三者都可以利用后续参数传参,apply可以传类数组或者arguments，但是call,bind只能单个每个传递(用逗号隔开) bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。","categories":[],"tags":[]},{"title":"JS的异步与事件循环探微","slug":"JS-asynchronous","date":"2021-04-28T17:30:00.000Z","updated":"2021-05-18T00:38:07.978Z","comments":true,"path":"2021/04/28/JS-asynchronous/","link":"","permalink":"http://example.com/2021/04/28/JS-asynchronous/","excerpt":"","text":"JavaScript起源1994年，网景公司（Netscape）发布了Navigator浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。 网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。1995年JavaScript诞生了,起初名字为Livescript，但是后来网景与Sun公司成立了一个开发联盟。Sun公司那时大肆宣传Java这种语言可以”一次编写，到处运行”（Write Once, Run Anywhere），后面LiveScript改名为JavaScript，本质上来说JavaScript和Java没什么关系（单纯蹭热度）。 如今，JavaScript的用途而是具备了与浏览器窗口及其内容等几乎所有方面交互的能力,已经成为一门功能全面的编程语言。 同步与异步,阻塞与非阻塞计算机领域中的同步（Synchronous）和异步（Asynchronous）和我们生活中的同步和异步的概念是不太一样。生活中的同步，突出的是‘同’，相同的步伐，是咱俩一起行动，比如一起去逛街吃饭饭睡觉觉。异步则是你忙你的，我忙我的，步调不致且互不干扰。到计算机里的同步和异步则关注的是消息通知机制。 计算机领域所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。 而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。 打个比如:以打电话为例,你给小明打电话,问他借本书,如果是同步机制,小明就会说,我看一下哈，不知道有没有,（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，小明直接告诉你我查一下啊,看看我的书柜里面有没有,查好了打电话给你,然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里小明通过“回电”这种方式来回调。 这里需要与阻塞非阻塞做一下区分,阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态. 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 还是上面的例子，你打电话问小明有书借没，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管小明有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下小明有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟小明通过什么方式回答你结果无关。 JavaScript Engine(Js 引擎)js 引擎即 js 虚拟机，主要是负责解析和执行 js 的，它是浏览器所实现的，不同的浏览器有不同的实现方式「采用 c/c++ 实现」，这里以比较流行V8引擎为例来说明该引擎包括两个主要组件： Memory Heap 内存堆 —— 这是内存分配发生的地方 Call Stack 调用堆栈 —— 这是在你代码执行时栈帧存放的位置(js 是单线程说的就是 call stack) 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程。浏览器有渲染引擎和 js引擎，浏览器是从上向下解析 html 标签的，当遇到 script 标签(js 代码)时会立即停止解析，直接执行 js 脚本，所以渲染引擎和 js 引擎是互斥的(js 操作 DOM 的会影响渲染)，这一个过程是同步的，所以加载一个耗时的 js 会导致界面卡死的，影响用户体验。 另外假定js同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，Js就是单线程，这已经成这门语言的核心特征，将来也不会改变。 注:webworker支持多线程,但是不能访问DOM。 Call Stack(调用栈)先上代码12345678function multiply(x, y) &#123; return x * y;&#125;function printSquare(x) &#123; var s = multiply(x, x); console.log(s);&#125;printSquare(5); 当引擎开始执行这个代码时，call stack将会变成空的。之后，执行的步骤如下： call stack的每个入口被称为 stack frame（栈帧）。顾名思义,栈即遵循先进先出原则，当一个方法调用的时候就入栈，执行完成以后就出栈。 Web APIs看完前面的铺垫你是否会产生这些疑问，由于 js 引擎中的 call stack同一时间只能干一件事情，那么他是如何是实现异步操作的？因为Js引擎只能自上而下执行,万一上一行解析时间很长,调用者一直等待着结果的返回,那么下面的代码不就被阻塞了么。 答案是虽然 js 是单线程的，但浏览器却是多线程的，我们知道 js 有好多 API 有些不是核心 js 语言的一部分，比如 BOM DOM AJAX setTimeOut Canvas WegGl 等 api 浏览器可以在调用之外执行这些 api(另起一个或多个线程跑这些 api) 这些 api 就可以独立于调用栈call stack来执行自己的功能，但是有一个问题是如果这些 api 执行完以后该怎么办呢？有两种方案 我们将 web api 完成的方法直接推送到调用栈call stack 我们采取一些机制来保存这些响应，在合适的时候推送给调用栈 第 1 种方法显然不靠谱，如果 web api 执行完以后直接把结果给调用栈可以会影响正在执行的调用栈，所以浏览器采用第二种方法，使用消息队列来保存这些 web api 执行的响应以便在调用栈可以调用的时候推送给调用栈，这个保存消息的东西就是接下来我们要说的 Message Queue Message Queue(回调队列)Message Queue(消息队列也叫 Callback Queue)是用来保存 Web Api 调用完成以后的所有消息的回调函数，当call stack为空时(也就是调用栈中的方法执行完毕以后)Message Queue 中的回调方法(先进先出)会被添加到call stack 中去执行，但是浏览器是什么方式来把调用栈和 message Queue 联系起来的「什么机制把 Message Queue 中的回调方法给 call stack 当 call stack 为空的时候」，它就是 Event Loop Event Loop(事件循环)Event Loop 是把 call stack 和 Message Queue 联系起来的纽带和桥梁，Event Loop 是一个基于事件的并发模型，它时刻在监听着消息队列，如果有完成的消息它此刻还要关心 call stack 是否为空，如果为空则把 Messag Queue 中的回调结果推送给 call statck 回调方法执行Event Loop 做两件事情1、监听 Message Queue(是否有消息)2、监听 call statck (看是否为空，如果为空则推送结果) 经典问题： 123456 console.log(&#x27;1&#x27;)setTimeout(function()&#123; console.log(&#x27;2&#x27;)&#125;, 0)console.log(&#x27;3&#x27;) // 1，3，2 我们来分析一下,当上面的代码加载在浏览器中步骤是什么样子: console.log(‘1’)被推到调用栈中然后当结束时从栈中被移除。 接下来setTimeOut( )函数被调用，所以它被推到了栈顶。setTimeOut( )有两个参数：一是回调，二是毫秒数。 浏览器单独开一个线程去执行这个setTimeOut( )方法在web APIs环境中开始了一个0秒的计时器此时，setTimeOut( )执行完毕并被移出栈。 console.log(‘3’)被推到栈里，执行完后被移除。 web api 执行 setTimeout 方法完毕，将结果给 Message Queue ，此是 web api 就变成空的，栈也已经变成空的，Event Loop 监听着 Message Queue。 Event loop 把 Message Queue 中的方法取出来，推给空的调用栈. 执行其中的方法体 console.log(‘2’)， 执行完毕 出栈，调用栈变为空 宏任务与微任务以上的Event Loop过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。 以下事件属于宏任务： setInterval() setTimeout() setImmediate() I/O 以下事件属于微任务: process.nextTick() new Promise()(有些实现的promise 将 then 方法放到了宏任务中，浏览器默认放到了微任务) Object.observe (已废弃) MutationObserver（不兼容，已废弃） MessageChannel（vue中 nextClick 实现原理） 前面我们介绍过，在一个Event Loop中，异步事件返回结果后会被放到一个Message Queue中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。 我们只需记住当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次Event Loop中，微任务永远在宏任务之前执行。 这样就能解释下面这段代码的结果：12345678910111213setTimeout(function () &#123; console.log(1);&#125;);new Promise(function(resolve,reject)&#123; console.log(2) resolve(3)&#125;).then(function(val)&#123; console.log(val);&#125;)# 2# 3# 1 总结到此我们把 js 非阻塞和异步,Call back 与Event Loop原理有所了解，现在总结一下 同步指的是发起调用后，调用方主动等待调用结果；异步指的是,发起调用后，调用者没有立刻得到返回结果,后续可通过回调等方式获取其结果。 阻塞关注的是等待调用结果时的状态,若线程挂起，等待结果返回就是阻塞.若调用在不能立刻得到结果之前，该调用不会阻塞当前线程会立刻返回则是非阻塞 js 是非阻塞异步的单线程(单线程指的就是 Call stack) js 实现异步的方式是基于 Event Loop 的并发模型 浏览器的 web api 不是 js 核心的部分，但是和 call stack 不冲突执行(浏览器另外开线程去执) web api 的执行结果不能直接给 call stack 先要通过 Message Queu 把结果存起来，等待 Event Loop 去处理 Event Loop 如果发现 call statck 为空时「此时就是推入 Message Queue 中的消息的最佳时机」取出消息队列中的消息推入给调用栈，异步结束 Message Queue分两种宏任务消息队列,微任务消息队列,同一次Event Loop中，微任务永远在宏任务之前执行 参考 https://www.jianshu.com/p/e865c3a7ba10 https://juejin.im/post/5c9de08e51882568093c1e9d","categories":[{"name":"原理探索","slug":"原理探索","permalink":"http://example.com/categories/%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"异步","slug":"异步","permalink":"http://example.com/tags/%E5%BC%82%E6%AD%A5/"},{"name":"事件循环","slug":"事件循环","permalink":"http://example.com/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"}]},{"title":"浅谈爬虫入门","slug":"learn-spider","date":"2021-04-28T17:25:35.000Z","updated":"2021-05-18T00:38:07.978Z","comments":true,"path":"2021/04/28/learn-spider/","link":"","permalink":"http://example.com/2021/04/28/learn-spider/","excerpt":"","text":"爬虫原理 网络抓取程序，俗称“爬虫”，爬虫的基本原理就是获取目标网址，下载网页，通过分析数据中的关键信息，获取资源。爬虫这个实际是翻译自英文的spider, 实际是蜘蛛的意思， 这个比喻很形象，蜘蛛在网上伺机而动，捕获食物。而我们的爬虫程序也就在Inerternet上爬取我们所需要的网络资源。 作用爬虫最重要的作用是充当搜索引擎，最简单的，我们上网浏览网页， 那我把网页都抓下来。建立了一个库，根据你搜的那个关键字（query），给你返回相应的数据，里面当然会根据相关度建立指标，比如比较权威的page rank,有那些权威的网站引用了，那个相关度就增高了。 百度和谷歌每天都会更新这个库。最早做搜索的时候，有种比较流氓的做法，就是去爬取竞争对手的搜出来的结果， 每个早期公司都会这个做，像之前百度会有参数叫谷歌参数，在搜索权重里面站的参数还比较重。 360就更厉害了，干脆把竞争对手直接抓过来后，直接建立一个库，然后返回数据给用户，这个真是比较机智。到后面都占据搜索市场10%以上。当然这里有个法律安全问题。 第二个作用是数据统计及分析， 这个范围就更多更广了，举一个很简单的例子，想看看各大招聘网站各类职务信息和热门网站以及薪水，想抓取雪球高回报用户的行为，找出推荐股票等等，我们都可以使用爬虫技术，来给我们收集数据，辅助我们决策。 基础知识现在我们进入本文的重点， 掌握爬虫技术需要那些知识和学习阶段的建议。 编程语言 首先入门，需要学习一门编程语言，以Python为例，基础语法、类、函数、数据结构中的list和dict等，跟着例子敲敲，网上资源很多，书籍像《笨办法学Python》， 网站像廖雪峰的个人网站，都是有不错的资源。 HTTP协议 爬虫就是通过网络请求从远程服务器下载数据的过程，互联网消息传输的基本协议就是http协议，先了解基本的get，post，delete等方法和编码。慢慢地掌握浏览器是发送http请求向目标站点获取资源信息，熟悉格式规范。网络请求框架都是对 HTTP 协议的实现，Python语言中著名的网络请求库 Requests 就是一个模拟浏览器发送 HTTP 请求的网络库。相当于通过这个库打开的新世界的大门， 我们可以获取网页的源代码。了解 HTTP 协议之后，学有余力，你就可以专门有针对性的学习和网络相关的模块了，Python 自带有 urllib、urllib2（Python3中的urllib），httplib，Cookie等内容，也可以暂时先跳过。把requests的API弄熟。 Html语言 很基础的内容，我们要爬取网页，自然需要知道网页使用的技术，知道文档树概念，30分钟就大致了解即可。 数据格式（HTML文本， XML 或者Json格式）我们通过网络请求库 Reuests 获得从网站服务器后端发过来数据，数据有可能有不同的格式正确处理这些数据，你要熟悉每种数据类型的解决方案，比如 JSON 数据可以直接使用 Python自带的模块 json等。 解析工具我的的目标信息藏在网页里，那么通过什么方法可以提取呢？传统的方法是使用正则表达式（Python模块中的re），对于Python而言，我们有方便的第三方解析库，可以使用。像Pyquery，BeautifulSoup等，学习方法最快速的无非是看官方文档中的quickstart先熟悉API。推荐使用Pyquery,它模仿Jquery几乎同样的API接口，对DOM操作十分方便。 数据库知识 爬取的数据需要持久化，数据库基本知识也需要掌握（MySQL、SQLServer、Oracle、Mongodb等）SQL语言（懂基本的增删改查：add、delete、update、select），时下非关系型数据库很流行，像Mongodb使用起来就简单便利。 网络抓包/浏览器抓包 学会使用 Chrome 或者 FireFox 浏览器去审查元素，跟踪请求信息等等，现在大部分网站有配有APP和手机浏览器访问的地址，优先使用这些接口，相对更容易。还有 Fiddler 等代理工具的使用。 Ajax技术原理 实际上就是浏览器提供了使用 HTTP 协议收发数据的接口，名为 AJAX，这像技术在web应用还比较广泛的，在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。学习了以上，基本也清晰了整个爬取过程。一般地一个爬虫程序组成部分如首先Downloader 负责下载页面（requests、urllib），其次HTMLParser 负责解析页面（Pyquery lxml BeautifulSoup），最后是根据业务逻辑获取dataModel字段，完成资源采集。 爬虫与反爬虫当然作为被爬取的一方，我然有我不希望被被人爬取的内容，那限制爬取这些内容一般在robots.txt里。一个文明的爬虫，如搜索引擎的爬虫，首先在网站根目录查看是否有此列表，依此来确认访问范围。以知乎为例www.zhihu.com/robots.txt 以上不允许爬取的内容就是相当于立了牌子，说禁止入内，robots.txt 只是约定，爬虫遵守或者不遵守完全在于爬虫作者的意愿。下面仅从技术的角度尝试探讨，反爬取策略与应对措施。 User-Agentheader字段增加User-Agent检测，或者还有部分网站会对Referer进行检测（资源网站的防盗链就是检测Referer）可以直接在爬虫中添加Headers，将浏览器的User-Agent复制到爬虫的Headers中；或者将Referer值修改为目标网站域名。对于检测Headers的反爬虫，在爬虫中修改或者添加Headers就能很好的绕过。 IP代理池 还有部分网站是通过检测用户行为，例如同一IP短时间内多次访问同一页面，或者同一账户短时间内多次进行相同操作。大多数网站都是前一种情况，对于这种情况，使用IP代理就可以解决。可以专门写一个爬虫，爬取网上公开的代理ip，检测后全部保存起来。这样的代理ip爬虫经常会用到，最好自己准备一个。有了大量代理ip后可以每请求几次更换一个ip，这在requests或者urllib2中很容易做到，这样就能很容易的绕过第一种反爬虫。对于第二种情况，可以在每次请求后随机间隔几秒再进行下一次请求。有些有逻辑漏洞的网站，可以通过请求几次，退出登录，重新登录，继续请求来绕过同一账号短时间内不能多次进行相同请求的限制。 cookies池 网站限制一些操作需要在登录的情况下,从存储模块获取用户名称，密码模拟登录，判断登录成功,爬取对应链接带上从cookies池里面随机获得的cookies,完成爬去工作。 模拟人为操作 上述的几种情况大多都是出现在静态页面，还有一部分网站，我们需要爬取的数据是通过ajax请求得到，或者通过JavaScript生成的，像很多页面频繁更新常采用这种方法。首先用需要对网络请求进行分析。如果能够找到ajax请求，也能分析出具体的参数和响应的具体含义，我们就能采用上面的方法，直接利用requests或者urllib2模拟ajax请求，对响应的json进行分析得到需要的数据。能够直接模拟ajax请求获取数据固然是极好的，但是有些网站把ajax请求的所有参数全部加密了。我们根本没办法构造自己所需要的数据的请求。除了加密ajax参数，它还把一些基本的功能都封装了，全部都是在调用自己的接口，而接口参数都是加密的。遇到这样的网站，我们就不能用上面的方法了，方法是selenium+phantomJS框架，调用浏览器内核，并利用phantomJS执行js来模拟人为操作以及触发页面中的js脚本。从填写表单到点击按钮再到滚动页面，全部都可以模拟，不考虑具体的请求和响应过程，只是完完整整的把人浏览页面获取数据的过程模拟一遍。 验证码当爬取操作，被网站判断为异常触发验证码来验证。当然我们python有优秀的图像识别库PIL库，也有识别验证码的库如pytesser,这不是本文重点，如果具体涉及到验证码识别这是算法工程师的事情了，对于一个优秀的爬虫工程师而言，自然是能规避出现验证码的情况。 总结爬虫作为python最容易上手的方向之一，是比较容易让学习者有成就感的。一个网站能够防80%的爬虫已经算是很优秀，毕竟反爬虫可能误伤，降低用户体验。本文梳理了爬虫大概，希望有助于初学者入门。","categories":[{"name":"技术概览","slug":"技术概览","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Git入门指南","slug":"how-to-use-git","date":"2021-04-28T17:14:32.000Z","updated":"2021-05-18T00:38:07.978Z","comments":true,"path":"2021/04/28/how-to-use-git/","link":"","permalink":"http://example.com/2021/04/28/how-to-use-git/","excerpt":"","text":"引言Git是2005年Linus Torvalds 为了帮助管理 Linux(R) 内核开发而开发的一个开放源码的版本控制软件, 可以说是当今世界上最先进的分布式版本控制系统。 SVN与GitSVN作为集中式版本控制系统的,版本库放在中央服务器。代码贡献者将各自的代码推送到中央服务器。这也就决定了集中式的版本控制系统必须联网,而且网速还不能慢。 Git与之相反，是分布式的，它没有中央服务器,每个人的电脑是一个完整的版本库,这样工作就不需要联网，多人协作就靠将各自的修改推送给对方，就可以互相看到对方的修改了。 本篇试简单介绍Git的常用操作与原理 Workspace：工作区,即在电脑中看到的目录 Index / Stage：暂存区，存放在.git目录下的index文件中 Repository：仓库区（或本地仓库）工作区有一个隐藏目录.git,不算工作区，是git的版本库 Remote：远程仓库 新建代码库 在当前目录新建一个Git代码库1git init 新建一个目录，将其初始化为Git代码库1git init [project-name] 下载一个项目和它的整个代码历史1git clone [url] 克隆指定分支 1git clone -b [branch] [url] 配置 显示当前的Git配置 1git config --list 编辑Git配置文件1git config -e [--global] 设置提交代码时的用户信息12git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 增加/删除文件 添加改动文件(添加到暂存区)添加所有改动文件（不包括 .gitignore 忽略的文件）: 1git add * 添加指定文件到暂存区 1git add [file1] [file2] ... 添加指定目录到暂存区，包括子目录1git add [dir] 添加当前目录的所有文件到暂存区1git add . 添加每个变化前，都会要求确认对于同一个文件的多处变化，可以实现分次提交1git add -p 查看文件改动和提交状态1git status 查看具体文件改动对比(工作区与版本库最新版本)1git diff HEAD -- [file] 删除所有未添加文件的改动（使 git status 恢复到 clean 状态）1git checkout . 删除某个文件的当前修改（未提交到暂存区）1git checkout -- [file] 删除工作区文件，并且将这次删除放入暂存区1git rm [file1] [file2] ... 停止追踪指定文件，但该文件会保留在工作区1git rm --cached [file] 改名文件，并且将这个改名放入暂存区 1git mv [file-original] [file-renamed] 代码提交 提交暂存区到仓库 1git commit -m [message] 提交暂存区的指定文件到仓库区1git commit [file1] [file2] ... -m [message] 提交工作区自上次commit之后的变化，直接到仓库区1git commit -a 提交时显示所有diff信息1git commit -v 使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息1git commit --amend -m [message] 重做上一次commit，并包括指定文件的新变化1git commit --amend [file1] [file2] 分支的操作 查看所有分支1git branch 列出所有远程分支1git branch -r 列出所有本地分支和远程分支1git branch -a 新建一个分支，但依然停留在当前分支1git branch [branch-name] 新建一个分支，并切换到该分支1git checkout -b [branch] 新建一个分支，指向指定commit1git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系1git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区1git checkout [branch-name] 切换到上一个分支1git checkout - 建立追踪关系，在现有分支与指定的远程分支之间1git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支1git merge [branch] 选择一个commit，合并进当前分支1git cherry-pick [commit] 删除分支1git branch -d [branch-name] 当分支上面还有未完成的提交时，需要强制删除1git branch -D [branch-name] 删除远程分支 12git push origin --delete [branch-name]git branch -dr [remote/branch] 本地从远程分支拉取新建分支并切换到新分支 1git checkout -b [branch-name] [remote/branch] 标签 列出所有tag1git tag 新建一个tag在当前commit1git tag [tag] 新建一个tag在指定commit1git tag [tag] [commit] 删除本地tag1git tag -d [tag] 删除远程tag1git push origin :refs/tags/[tagName] 查看tag信息1git show [tag] 提交指定tag1git push [remote] [tag] 提交所有tag1git push [remote] --tags 新建一个分支，指向某个tag 1git checkout -b [branch] [tag] 查看信息 显示有变更的文件 1git status 显示当前分支的版本历史1git log 显示commit历史，以及每次commit发生变更的文件1git log --stat 搜索提交历史，根据关键词1git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行1git log [tag] HEAD --pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件1git log [tag] HEAD --grep feature 显示某个文件的版本历史，包括文件改名12git log --follow [file]git whatchanged [file] 12* 显示分支合并图 一行显示git log --graph --pretty=oneline --abbrev-commit # 得到sha1计算的版本号commit id 显示指定文件相关的每一次diff1git log -p [file] 显示过去5次提交1git log -5 --pretty --oneline 显示所有提交过的用户，按提交次数排序1git shortlog -sn 显示指定文件是什么人在什么时间修改过1git blame [file] 显示暂存区和工作区的差异1git diff 显示暂存区和上一个commit的差异1git diff --cached [file] 显示工作区与当前分支最新commit之间的差异1git diff HEAD 显示两次提交之间的差异1git diff [first-branch]...[second-branch] 显示今天你写了多少行代码1git diff --shortstat &quot;@&#123;0 day ago&#125;&quot; 显示某次提交的元数据和内容变化1git show [commit] 显示某次提交发生变化的文件1git show --name-only [commit] 显示某次提交时，某个文件的内容1git show [commit]:[filename] 纪录每一次命令，可用于查找某一提交版本的 commit id。 1git reflog 远程同步 下载远程仓库的所有变动 1git fetch [remote] 远程仓库的删除与重命名12$ git remote rename [new_name] [old_name]$ git remote rm [old_name] 显示所有远程仓库1git remote -v 显示某个远程仓库的信息1git remote show [remote] 增加一个新的远程仓库，并命名1git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并1git pull [remote] [branch] 上传本地指定分支到远程仓库1git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突1git push [remote] --force 推送所有分支到远程仓库1git push [remote] --all 撤销 恢复暂存区的指定文件到工作区1git checkout [file] 恢复某个commit的指定文件到暂存区和工作区1git checkout [commit] [file] 恢复暂存区的所有文件到工作区1git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变1git reset [file] 重置暂存区与工作区，与上一次commit保持一致1git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变1git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致1git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变1git reset --keep [commit] 新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支1git revert [commit] 暂时将未提交的变化移除，稍后再移入1git stash 恢复操作(两步)123git stash apply # 恢复后，stash内容并不删除git stash drop # 此时stash内容删除git stash apply stash@&#123;0&#125; #多次stash 可以查看并恢复指定stash 恢复操作(一步)12git stash pop # 恢复的同时把stash内容也删了git stash list # 此时是空的 其他记录 创建分支修复临时bug1234567git checkout mastergit checkout -b issue-001# 完成修复git add *git commit -m &quot;fix bug 001&quot;git checkout mastergit merge --no-ff -m &quot;merged bug fix 101&quot; issue-001 # 保存之前的分支历史，更好查看merge历史,禁用fast forward 忽略特殊文件Git工作区的根目录下创建一个特殊的.gitignore文件 强制添加被忽略的文件到git1git add -f [file] 查看.gitignore是否是否规则有问题 1git check-ignore -v [file] 配置别名 针对用户 1234git config --global alias.st statusgit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branch 针对仓库在.git/config里面alias 里面配置","categories":[{"name":"常用技巧","slug":"常用技巧","permalink":"http://example.com/categories/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"测试博客","slug":"hello-world","date":"2021-04-25T20:27:57.000Z","updated":"2021-05-18T00:38:07.978Z","comments":true,"path":"2021/04/25/hello-world/","link":"","permalink":"http://example.com/2021/04/25/hello-world/","excerpt":"","text":"我的博客部署啦[1], 重要呀 iframe1&lt;iframe src=&quot;https://hexo.fluid-dev.com/&quot; width=&quot;100%&quot; height=&quot;500&quot; name=&quot;topFrame&quot; scrolling=&quot;yes&quot; noresize=&quot;noresize&quot; frameborder=&quot;0&quot; id=&quot;topFrame&quot;&gt;&lt;/iframe&gt; mardown要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： &lt;p&gt;这是一个普通段落：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;这是一个代码区块。 &lt;/code&gt;&lt;/pre&gt; 1$ hexo new &quot;My New Post&quot; More info: Writing 标签12345&#123;% note success %&#125;文字 或者 `markdown` 均可&#123;% endnote %&#125;&lt;p class=&quot;note note-primary&quot;&gt;标签&lt;/p&gt; 文字 或者 markdown 均可 标签 行内标签1&lt;span class=&quot;label label-primary&quot;&gt;Label&lt;/span&gt; Label 勾选框1&#123;% cb text, checked?, incline? %&#125; 默认选中 按钮1&#123;% btn url, text, title %&#125; text 组图1234567&#123;% gi total n1-n2-... %&#125; ![](url) ![](url) ![](url) ![](url) ![](url)&#123;% endgi %&#125; 代码块高亮1234567891011121314&lt;% if(!is_post()) &#123; %&gt;&lt;br&gt;&lt;span class=&quot;h2&quot; id=&quot;hitokoto&quot;&gt; &lt;% if(theme.fun_features.typing.enable == false) &#123; %&gt; &lt;%- hitokoto %&gt; &lt;% &#125; %&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;h2&quot; id=&quot;hitofrom&quot;&gt; &lt;% if(theme.fun_features.typing.enable == false) &#123; %&gt; &lt;%- hitofrom %&gt; &lt;% &#125; %&gt;&lt;/span&gt;&lt;% &#125; %&gt; mermaid流程图1234567891011121314classDiagramClass01 &lt;|-- AveryLongClass : CoolClass03 *-- Class04Class05 o-- Class06Class07 .. Class08Class09 --&gt; C2 : Where am i?Class09 --* C3Class09 --|&gt; Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 &lt;--&gt; C2: Cool label classDiagram Class01 &lt;|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --&gt; C2 : Where am i? Class09 --* C3 Class09 --|&gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 &lt;--&gt; C2: Cool label 公式 E=mc^2页脚本站 ↩","categories":[],"tags":[]},{"title":"博客转移成功啦!","slug":"multi-platform-submmit","date":"2021-04-24T19:47:28.000Z","updated":"2021-05-18T00:38:07.978Z","comments":true,"path":"2021/04/24/multi-platform-submmit/","link":"","permalink":"http://example.com/2021/04/24/multi-platform-submmit/","excerpt":"","text":"实现了源码提交到github,可以发markdown博客，通过github action构建静态网站托管到github/gitee/coding, 今天开始就可以快快乐乐下博客啦！","categories":[],"tags":[]},{"title":"linux的前世今生","slug":"birth-of-linux","date":"2019-03-24T16:27:42.000Z","updated":"2021-05-18T00:38:07.978Z","comments":true,"path":"2019/03/24/birth-of-linux/","link":"","permalink":"http://example.com/2019/03/24/birth-of-linux/","excerpt":"","text":"引言操作系统Operating System，简称OS，港台译作「作业系统」,是管理计算机硬件与软件资源的程序，同时也是计算机系统的核心与基石。日常我们用到的如: 微软win10系统 苹果mac的IOS系统 谷歌的Android系统 这些操作系统提供了，在其上运行的程序提高基本环境，当大家使用 Google 搜索时，使用微博热搜时，使用taobao购物时，使用微信聊天时，很多人并不知道，支撑这些软件和服务的，是后台成千上万台 Linux服务器，它们时时刻刻都在进行着忙碌的运算和数据处理，确保数据信息在人、软件和硬件之间安全的流淌。可以这么说，世界上大部分软件和服务都运行在 Linux 操作系统之上，神马云计算、大数据、移动互联网，说起来风起云涌，其实没有Linux全得歇菜（微软除外）。 梦回贝尔实验室1965年之前的时候，电脑并不像现在如此烂大街，可不是一般人能碰的起的，除非是军事或者学院的研究机构，而且当时大型主机至多能提供30台终端（30个键盘、显示器)，连接一台电脑，它的使用和维护成本非常之高。为了解决数量不够用的问题，1965年前后由贝尔实验室、麻省理工学院以及 通用电气共同发起了Multics项目，想让大型主机支持300台终端，1969年前后这个项目进度缓慢，资金短缺，贝尔实验室觉得没钱干不下去了，退出了研究。 Ken Thompson（左）Dennis Ritchie（右） 当时贝尔实验室中有个叫肯-汤姆逊（Ken Thompson）的人，闲着自己倒腾游戏，编写“星际旅行”(Space Travel)，为了能够上班在一台空闲电脑上玩，就用汇编开发了一个简单的操作系统，这个就是后来的Unix。所你你想想当你上班去干一件件事情的时候，往往结果还不如意，但是凭着兴趣随性往往收获意想不到。如果你关注这个肯-汤姆逊，你会知道他很有名，他除了创造了一个B语言（就是C语言的前身），而且他是plan9操作系统的创造者和开发者之一，2006年汤姆逊进入谷歌，2007年开始和其他几位工程师共同设计的Go语言，另外参加过正则表达式和UTF-8编码的设计，而这些事情凡人做一件也足以载入史册。另外一个很有意思的事情，就是在1969年操作系统Unix诞生的时候，林纳斯-托瓦兹（（Linus Benedict Torvalds））在芬兰呱呱落地。 Linus Benedict Torvalds 到了1972年的时候，肯-汤姆逊和丹尼-里奇（Dennis Ritchie），用汇编语言去做移植，实在是太苦逼了，两基友在电脑面前互相骂娘。而B语言可以被认为是那个时代的解释型语言，不能直接生成机器码，跨平台性差，难堪大任，为了能够在其他的电脑上也能够运行这个非常棒的Unix操作系统，他们想用高级语言来完成这个第三版，丹尼斯-里奇在B语言的基础上最终设计出了一种新的语言，他取了BCPL的第二个字母作为这种语言的名字，这就是C语言。从此一代语言巨星冉冉升起，40年后依然排在兵器排名榜第一位，怎一个牛字了得！到1973年初，哥俩成功地用C语言，重写了第三版内核，这个时候操作系统修改移植就变得相当的便利，为其普及打下非常坚实基础，Unix 与 C 从此珠联璧合，长相思守，再也无法分离，很快的成为世界的主导，最开始是学术界和大学是其的主要使用者，比如做一些教学，从那个时候逐渐流行起来。 Andrew S. Tanenbaum Unix纷争四起只不过开始也有了一些法律纠纷，主要是那个AT&amp;T(通用电气)，它企图私有化UNIX,让很多软件开发者很痛心和焦虑。塔能鲍姆(Andrew S. Tanenbaum)教授为了能在课堂上教授学生操作系统运作的实务细节，决定在不使用任何AT&amp;T的源代码前提下，自行开发与Unix兼容的操作系统，以避免版权上的争议。他以小型UNIX（mini-Unix）之意，将它称为Minix。 Richard Matthew Stallman 伟大的布道者同时理查德-斯托曼（Richard Matthew Stallman）出现了。 搞IT的都知道，这位活着的传奇，自由软件运动的布道者，上图：络腮满面，泡面长发配圆顶礼帽，大肚配罩衫，无一处不荒诞，却也无一处不可爱，正如这位大师级顽童的程序生涯般耐人寻味。 理查德-斯托曼认为Unix可能是好的操作系统，如果大家能够将所学进行贡献出来，那么这个系统将会更加的优异，他倡导开源，在80年代的大环境下，他要实现一个，自由的，类Unix的操作系统，他这个想法也得到了很多人的认同，并且有一些捐助者支持他这个理想。理查德-斯托曼在1983年创立了这个GNU（GNU’s Not Unix!的递归缩写）项目，计划开发一套与UNIX相互兼容的操作系统，在1985年10月份，他又创立了这个自由软件基金会(Free Software Foundation)，为GNU提供一些法律和一些财务上面的支持，接着他开发了GCC、GDB、GNU Emacs，同时编写了GNU通用公共许可协议（GNU General Public License即GPL），但是由于很多原因，GNU自己的操作系统迟迟没有完成开发。 那这个内核他有多重要呢？ 首先它是一个系统级别的软件，它是用来管理在其上运行的软件发出的数据IO的输入和输出请求。将这些请求会转译成一个数据处理的指令，交由CPU也就是中央处理器和电脑中其他的电子组件进行处理，是现在操作系统中非常基本的一个部分。Linux许多人都使用它，但它仅仅是你所用这个系统中的一部分，是一个内核，它为运行的其他的程序分配计算机的资源，是很基础的部分，只能在完整的操作系统框架下才能发挥作用，通常Linux就和GNU作系统是一起使用的，而整个系统就是GNU和Linux，所以有时候你能看到名字叫GUN/Linux，所有Linux的发行版，实际上是GUN/Linux的发行版。 linux之父-林纳斯林纳斯的外公是赫尔辛基大学的一位统计学教授，数学家。他有一台Commodore VIC-20计算机，爷子年老眼花，也不愿意打字，外孙小的时候就把林纳斯纳斯放在腿上，让他帮助录入写在纸片上的程序。这种很有场面感的场景一再出现后，李纳斯除了对数学有了初步的认识，同时也把计算机玩的娴熟，10岁的时候，很快他就在外公的指导下开始编写自己的程序。 我们10岁在干什么，打沙包么？小霸王么？让20多岁才开始编程的同学一入世就差别人十年的身位，除了冷冷的绝望，你还能感受到什么？ Linus Benedict Torvalds 林纳斯在1989年服了11个月芬兰国家义务兵役期间，就购买了塔能鲍姆所著的教科书《操作系统：设计及实现》及Minix源代码，开始研究操作系统。在他的自传《Just For Fun》中，托瓦兹把这本书描述为“引领我到达新高度的一本书籍”。 1990年，而林纳斯此时在外公所在的赫尔辛基大学上学，他最初是用汇编语言写了一个英特尔30386CPU处理多任务切换的一个程序。而塔能鲍姆的操作系统Minix由于其用于教学，他不愿意做更多的功能的更新，比如性能问题、内核问题、文件系统问题和终端仿真器等诸多问题，导致一堆工程师和学生在这个作业系统功能上面吐槽满满。林纳斯想既然如此，那我何不自己来改写一个我想要的作业系统？于是基于Minix的灵感，他开始写一些硬件的设备的驱动程序，还有一个很小的文件系统，这样0.01版本的就出来了。但是它只是具有个操作系统内核勉强的雏形。但又不能运行，因为他必须要在有Minix的机器上编译之后才能用，那个时候也没有现在的网络条件，常见的就是一个新闻组，所以他在新闻组里面发布了一个Linux早期版本的通告。 从一开始，林纳斯就决定自由扩散包括它的源代码。发布后随即Linux立刻引起了很多黑客们的注意，并且通过计算机互联网加入了linux内核开发。这时候林纳斯经完全着迷，不想听停止，决定踢开Minix。于是在1991年10 月5号发布Linux 0.0.2版本,在这个版本中已经可以运行bash 和gcc。由于一批高水平的黑客的加入，使得linux开发迅速蓬勃起来。几乎一两个礼拜就会有新的版本和修正版本出现，所以在93年底到94年初的时候，linux1.0诞生，这个时候linux已经是一个功能很完备的操作系统，而且写得非常的紧凑高效，可以充分发挥硬件的性能，在4m内存的80386的机器上面表现得非常好。 毫不吹嘘地说，他是一个非常伟大的架构师，并且他同时还有非常大的项目协调管理能力，从那时到现在他一直协调上千人的开发人员一起做linux开发工作，除此以外，他还发起了git，他是主要的开发者，造福千万码农。他性格鲜明，在网上邮件列表中也以火暴的脾气著称，因Nvidia一直没有针对Linux平台发布任何官方的Optimus支持，托瓦兹当众对着镜头竖起了中指，说 ‘So, Nvidia, fuck you!’，在他的领域里，无法容忍废话与缺陷，极致地完美主义者。 GNU与LinuxLinux的历史是和GNU紧密联系在一起的。从1983年开始的GNU计划致力于开发一个自由并且完整的类Unix操作系统，包括软件开发工具和各种应用程序。到1991年 Linux 内核发布的时候，GNU已经几乎完成了除了系统内核之外的各种必备软件的开发。GNU实际上也同时在开发内核，不过他在开发过程中意识了有很多问题，正好是由于linux出现，1992年的时候，林纳斯在GPL v2协议下，发布了0.1.2版的内核，这个使得linux变成自由系统，它填补了GNU系统的一个重要的空白，linux用户在挑选软件方面有非常大的自由，比如说，你今后可以选择几十种不同的命运行外壳和多种的图形的桌面，这个其实Windows的用户感觉很不习惯，linux另外的特点，就是很少崩溃，适合同时间运行多个程序，而且比大部分的操作系统安全，如果你用过windows系统是做过服务器，你能理解Linux为什么是服务器市场上增长最快的操作系统。 大教堂与市集讲一个小插曲，《大教堂与市集》，是埃里克•斯蒂芬•雷蒙（Eric Steven Raymond）所撰写的软件工程方法论，他是以linux这个核心开发过程以及作者自己主持开发的开源代码Fetchmail为讨论案例的，这个文章是1997年5月29号发表的，在1999年他出版成书，他主要讨论两种的，自由软件开发模式，第一种大教堂的模式源代码在软件发行后公开，软件每个版本开发过程中，都是有一个专属的团队所管控的，比如说，GNU Emacs就是。另外一种模式是即集市，代码在开发过程中，就在互联网上公开。供别人查看然后开发，这个是指林纳斯带领linux核心开发为例子，这么做的观点是让足够多的人看到源代码，让错误无所遁形，大教堂模式的软件开发者模式，会让编程排错的的时间大大的增加，因为只有少数的开发者可以参与新的工作。市集的模式正好相反。市集模式也影响了原来采用大教堂模式的GNU Emacs及GCC释放源码。现在看到的场景来说，市集这种设计模式已经无所不在。 BSD与Linux最后讲一下BSD。除了GUN以外，还有一个独立进行工程，开发了一个，自由的类型UNINX的操作系统就是BSD，他由UC伯克利开发。在80年代BCD里它还不是自由的，但是他在90年代变成了自由软件，我们现在看到了这些自由的操作系统，如果不是GUN系统派生的，那就是BSD系统派生的，BSD的代码和GNN并不重合，BSD系统现在也使用一些GUN的程序，GUN系统使用了BSD程序是一样的，整体来看，属于独立开发的不同系统。BSD和GUN开发的协议是不一样的。但由于法律因素中，还有些诸多的其他的原因，没让BSD没像GUN流行起来，这么广泛的传播。BSD有很多的分支，比如主流的FreeBSD(最受欢迎的 BSD)、NetBSD(被设计运行在几乎任何架构上)、OpenBSD(为最大化的安全性设计的)。 Darwin的是苹果在2000年开放源代码操作系统，在Darwin系统内核中就包括了一个BSD系统，与其他的 BSD 有点不同，虽然底层内核和其他的软件是开源代码(BSD 代码)，但操作系统的大部分是闭源的 Mac OS 代码)。苹果在 BSD 基础上开发了 Mac OS X 和 IOS，这样他们就不必写操作系统底层，就像谷歌在 Linux 基础上开发 android 系统一样。","categories":[{"name":"科普文章","slug":"科普文章","permalink":"http://example.com/categories/%E7%A7%91%E6%99%AE%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"历史","slug":"历史","permalink":"http://example.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"python系列","slug":"python系列","permalink":"http://example.com/categories/python%E7%B3%BB%E5%88%97/"},{"name":"原理探索","slug":"原理探索","permalink":"http://example.com/categories/%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/"},{"name":"技术概览","slug":"技术概览","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/"},{"name":"常用技巧","slug":"常用技巧","permalink":"http://example.com/categories/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"科普文章","slug":"科普文章","permalink":"http://example.com/categories/%E7%A7%91%E6%99%AE%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"异步","slug":"异步","permalink":"http://example.com/tags/%E5%BC%82%E6%AD%A5/"},{"name":"事件循环","slug":"事件循环","permalink":"http://example.com/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"历史","slug":"历史","permalink":"http://example.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}